# Tool Execution Component - Reflexion System

## Overview

This document explains how the tool execution component works within the Reflexion System. The system enables an AI to generate answers, critique them, search for improvements, and iteratively revise its responses.

---

## Message Flow Architecture

The complete flow consists of three types of messages:

1. **HumanMessage** - Initial user question
2. **AIMessage** - Generated by the responder chain containing:
   - Initial answer
   - Self-critique (reflection)
   - 3 search queries for improvement
3. **ToolMessage** - Generated by `execute_tools()` containing compiled search results

### Execute Tools Component

The `execute_tools()` method has a simple but critical job:

1. Extract the last message (AIMessage) from the state
2. Parse the search terms from the tool call
3. Loop through each search term
4. Call Tavily Search API for each term
5. Compile all results into one ToolMessage

**Key Point:** Each component contributes one message to the conversation chain:

- Human → 1 HumanMessage
- Responder → 1 AIMessage
- Execute Tools → 1 ToolMessage

---

## System Components

### 1. Schema Definitions (Pydantic Models)

- **`AnswerQuestion`** - Structure for initial response with critique
- **`ReviseAnswer`** - Structure for improved response with citations
- **`Reflection`** - Schema for self-critique

### 2. Tool Executor

- **`execute_tools()`** - Function that processes tool calls and executes searches

### 3. External Tool

- **`TavilySearchResults`** - Web search API (max 5 results per query)

---

## Step-by-Step Flow

### Step 1: User Asks a Question

```python
HumanMessage(content="Write about how small business can leverage AI to grow")
```

---

### Step 2: AI Generates Initial Response (Tool Call)

The AI doesn't directly answer. Instead, it makes a **tool call** to `AnswerQuestion`:

```python
AIMessage(
    content="",  # Empty because this is a tool call, not a text response
    tool_calls=[{
        "name": "AnswerQuestion",
        "args": {
            'answer': 'Small businesses can leverage AI...',  # ~250 word initial answer
            'search_queries': [
                'AI tools for small business',
                'AI in small business marketing',
                'AI automation for small business'
            ],
            'reflection': {
                'missing': 'Specific cost information and ROI examples',
                'superfluous': 'Too much general overview without concrete examples'
            }
        },
        "id": "call_KpYHichFFEmLitHFvFhKy1Ra"  # Unique ID to track this tool call
    }]
)
```

**What's happening:**

- ✅ The AI generates a draft answer (~250 words)
- ✅ It **critiques itself** (reflection) identifying gaps
- ✅ It determines what **search queries** would fill those gaps
- ✅ All this is wrapped in a structured tool call

---

### Step 3: Execute Tools (`execute_tools()` function)

The `execute_tools()` function processes the tool call:

```python
def execute_tools(state: List[BaseMessage]) -> List[BaseMessage]:
    last_ai_message: AIMessage = state[-1]  # Get the AI's last message
```

#### a) Extract Tool Calls

```python
if tool_call["name"] in ["AnswerQuestion", "ReviseAnswer"]:
    call_id = tool_call["id"]  # "call_KpYHichFFEmLitHFvFhKy1Ra"
    search_queries = tool_call["args"].get("search_queries", [])
    # search_queries = ['AI tools for small business', ...]
```

#### b) Execute Searches

```python
query_results = {}
for query in search_queries:
    result = tavily_tool.invoke(query)  # Searches the web
    query_results[query] = result
```

#### c) Result Structure

Each search query returns up to 5 results:

```python
{
    "AI tools for small business": [
        {"url": "https://...", "content": "..."},  # Result 1
        {"url": "https://...", "content": "..."},  # Result 2
        {"url": "https://...", "content": "..."},  # Result 3
        {"url": "https://...", "content": "..."},  # Result 4
        {"url": "https://...", "content": "..."}   # Result 5
    ],
    "AI in small business marketing": [
        {"url": "https://...", "content": "..."},
        # ... 5 results
    ],
    "AI automation for small business": [
        {"url": "https://...", "content": "..."},
        # ... 5 results
    ]
}
```

#### d) Create Tool Message

```python
tool_messages.append(
    ToolMessage(
        content=json.dumps(query_results),  # All search results as JSON string
        tool_call_id=call_id  # Links back to the original tool call
    )
)
```

---

### Step 4: Updated Conversation State

The `ToolMessage` is added to the conversation:

```python
[
    HumanMessage("Write about how small business can leverage AI to grow"),
    AIMessage(tool_calls=[...]),  # AI's request for search
    ToolMessage(content="{search results...}", tool_call_id="call_...")  # Search results
]
```

---

### Step 5: AI Revises Answer

Now the AI has access to:

- ✅ Original question
- ✅ Its initial answer and critique
- ✅ Web search results (15 total results from 3 queries)

It makes **another tool call** to `ReviseAnswer`:

```python
AIMessage(
    tool_calls=[{
        "name": "ReviseAnswer",
        "args": {
            'answer': '...',  # Improved answer using search results
            'search_queries': [...],  # Potentially more searches if needed
            'reflection': {
                'missing': '...',
                'superfluous': '...'
            },
            'references': [
                'https://example.com/article1',
                'https://example.com/article2'
            ]  # Citations from search results
        }
    }]
)
```

**The cycle can repeat** until the answer quality is satisfactory.

---

## Key Concepts Explained

### Why is `content=""` in the AI message?

- When an AI makes a tool call, it's **not speaking to the user**
- It's requesting to **execute a function** (the tool)
- The actual structured data is in `tool_calls`
- After the tool executes, the AI will generate a proper text response

### What's the `tool_call_id`?

- Links the `ToolMessage` response back to the specific tool call
- Multiple tool calls can happen simultaneously, so each needs unique tracking
- Ensures responses are matched to the correct requests

### Why the nested structure?

The `AnswerQuestion` schema forces the AI to:

1. ✅ Draft an answer (~250 words)
2. ✅ Critique itself with metacognition (reflection)
3. ✅ Request specific, targeted searches
4. ✅ Structure all outputs in a parseable format

This structured approach ensures:

- Quality through self-reflection
- Iterative improvement
- Traceable reasoning
- Evidence-based revisions

---

## Complete Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      User Question                          │
│  "Write about how small business can leverage AI to grow"  │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│              AI Generates Initial Response                  │
│  • Draft answer (~250 words)                                │
│  • Self-critique (missing/superfluous)                      │
│  • 3 search queries                                         │
│  → AnswerQuestion tool call                                 │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│            execute_tools() Runs Searches                    │
│  • Extracts search queries from tool call                   │
│  • Calls Tavily API for each query (5 results each)        │
│  • Compiles results into single ToolMessage                 │
│  → Returns 15 total search results                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│              AI Revises Answer                              │
│  • Reads search results                                     │
│  • Improves answer with new information                     │
│  • Adds citations/references                                │
│  • Self-critiques again                                     │
│  → ReviseAnswer tool call                                   │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
         ┌────────────┴────────────┐
         │  More improvement       │
         │  needed?                │
         └────┬──────────────┬─────┘
              │ YES          │ NO
              │              │
              └──────┐       ▼
                     │  ┌─────────────────┐
                     │  │  Final Answer   │
                     │  │  to User        │
                     │  └─────────────────┘
                     │
                     └──────────────────┘
                     (Repeat cycle)
```

---

## Design Pattern: Reflexion

This is an implementation of the **Reflexion pattern**, where:

1. **Generate** - AI creates an initial response
2. **Reflect** - AI critiques its own work
3. **Research** - System gathers additional information
4. **Revise** - AI improves the response with new knowledge
5. **Repeat** - Cycle continues until quality threshold is met

This approach leads to higher quality outputs through:

- Self-awareness and metacognition
- Evidence-based improvements
- Iterative refinement
- Transparent reasoning with citations

---

Tool Call = A Structured Request

When you see tool_calls in your code, the AI isn't calling a function yet.
It is generating a JSON request that says: "I want to run the function called
'AnswerQuestion' with these specific 'search_queries'.".

- The Model's Role: It looks at your AnswerQuestion schema and fills in the blanks (the arguments).

- The Output: It returns an AIMessage containing a list of tool_calls.
  Each call has a name, arguments, and a unique id.

2. Why it feels like a "Search Query" and not a "Function"
   In your specific Reflexion Agent code, you have defined a tool
   (a Pydantic model) called AnswerQuestion.
   You told the AI that this "function" requires a list of search_queries as an input.

- So, when the AI "calls" your function:
- It sends a tool_call for AnswerQuestion.

The Arguments of that call happen to be the search queries it wants to use.

Your Code (the execute_tools function) is the part that actually "calls"
the real Python function (tavily_tool.invoke) using those arguments.
